function [q_enc,qds,q] = gentraj(handle, robot, infile, prd, show)
% GENTRAJ Script to generate joint-space trajectories between waypoints in
% Cartesian space

%{
    [q_enc] = gentraj(handle, robot, infile, prd, show)
    Julian Leland, MIT Media Lab, 2016-06-08

    INPUTS:
    handle - LabJack handle
    robot - Robot description
    infile - String containing name of input text file to use for
    trajectory generation (generated by Homeprint)
    prd - Period/timestep to use for path generation
    show - Flag (1/0) to instruct whether to plot function outputs (plots
    of Cartesian position & velocity, joint position & velocity, robot
    path. If you don't set this to 0, the robot animation will display -
    which is pretty, but slow.

    OUTPUTS:
    q_enc: Nx9 matrix of encoder positions and velocities, which can be fed
    into a controller. Format is [time, J1pos, J2pos, J3pos, J4pos, J1vel,
    J2vel, J3vel, J4vel].
     - Note that J2pos and J2vel are constant/zero respectively, in this
     version of the code. This is because we don't use J2.
     - J1-J4vel are currently calculated by running a simple diff() on
     J1-J4pos - we don't actually use qds. The primary reason for this is
     that the mapping from joint angular velocity to piston linear velocity
     (relevant for J2 and J3) is not linear, so directly trying to convert
     from angular velocities calculated with jacob0 isn't straightforward.
     JL is working on this as of 2016-06-09.
    qds: Nx3 matrix of joint velocities. Calculated using jacob0
    q: Nx3 matrix of joint positions. Calculated 
%}
%% Initialize machine & paths
init;
close(findall(0,'type','figure')); % We are going to generate a whole bunch of figures - need to clean up before we do
addpath('lib/rvctools/common/');

%% Get current position of machine
Q_raw = [0,-3.7655,-5,-9];
Q_joint = raw2joint_at40gw(robot,Q_raw);
Q_joint
% TODO: Ask user whether they want to specify home position, or get start
% position from machine

%% Generate waypoints
[waypts, incell] = parsehomeprint(infile);
num_waypts = size(waypts, 1);
waypts = waypts(:,2:4);
owaypts = waypts;

%% Shift waypoints to home position
home_pos = joint2cart_at40gw(Q_joint); % Calculate endpoint position
home_pos
waypts = bsxfun(@plus,waypts,home_pos);

%% PLOT Cartesian Waypoints
if show
    mainfig = gcf;
    figure(mainfig);
    hold on;
    plot3(waypts(:,1),waypts(:,2),waypts(:,3));
    text(waypts(1,1),waypts(1,2),waypts(1,3),'t0');
    text(waypts(end,1),waypts(end,2),waypts(end,3),'tf');
    hold off;
end

%% Compute Cartesian trajectories
[trajpts, velpts] = mstraj2(waypts, [1000 1000 1000], [], home_pos, prd, 3);
if show
    figure(mainfig);
    hold on;
    scatter3(trajpts(:,1),trajpts(:,2),trajpts(:,3),'r.');
    hold off;
end


%% Plot cartesian velocities
if show
    figure;
    subplot(6,1,1);
    plot(1:size(trajpts,1),trajpts(:,1));
    title('x pos');
    subplot(6,1,2);
    plot(1:size(velpts,1),velpts(:,1));
    title('x vel');

    subplot(6,1,3);
    plot(1:size(trajpts,1),trajpts(:,2));
    title('y pos');
    subplot(6,1,4);
    plot(1:size(velpts,1),velpts(:,2));
    title('y vel');

    subplot(6,1,5);
    plot(1:size(trajpts,1),trajpts(:,3));
    title('z pos');
    subplot(6,1,6);
    plot(1:size(velpts,1),velpts(:,3));
    title('z vel');
end

%% Compute joint-space trajectories (using RVC tools)
mdl_AT40GW; % This function defines the AT40GW model using RVC's modeling framework. Available at Controls_Simulation/RVC_DH-FK-IK
Tp = transl(trajpts);
q = AT40GW.ikine(Tp,[],[1,1,1,0,0,0]);
if show
    figure(mainfig);
    AT40GW.plot(q);
end

%% Compute the Jacobians at each timestep
Jq = [];
for i=1:size(q,1)
    Jq(:,:,i) = AT40GW.jacob0(q(i,:),'trans',true);
end

%% Compute joint velocities at each point
vs = velpts;
Jqs = Jq;
qds = [];
for i=1:size(q,1)
    qds(:,i) = pinv(Jq(:,:,i))*[vs(i,:)]';
end

%% Plot joint positions & velocities over time
if show
    qds = qds'; % Need to transpose qds to plot with below code - retransposed at line 131
    figure;
    subplot(6,1,1);
    plot(1:size(q,1),q(:,1));
    title('Joint 1 pos');
    subplot(6,1,2);
    plot(1:size(qds,1),qds(:,1));
    title('Joint 1 velocities');
    subplot(6,1,3);
    plot(1:size(q,1),q(:,2));
    title('Joint 3 pos');
    subplot(6,1,4);
    plot(1:size(qds,1),qds(:,2));
    title('Joint 3 velocities');
    subplot(6,1,5);
    plot(1:size(q,1),q(:,3));
    title('Joint 4 pos');
    subplot(6,1,6);
    plot(1:size(qds,1),qds(:,3));
    title('Joint 4 velocities');
    qds = qds';
end

%% Collect paths into final path vector
[q_row,q_col] = size(q);

q_deg = zeros(q_row,q_col+1); % Make this one column wider than q so we can include nonactuated J2.
q_enc = zeros(q_row,(2*q_col)+1); % Make this 2*q_col + 1 so we can include velocity and timestamp

%% Calculate encoder position trajectory
% Convert radians to degrees
for n = 1:q_row
    q_deg(n,:) = [rad2deg(q(n,1)), Q_joint(2), rad2deg(q(n,2)), q(n,3)];
end

% Convert angles/mm to joint counts/volts
for n = 1:q_row
    q_time(n,:) = (n*prd);
    q_pos(n,:) = joint2raw_at40gw(robot,q_deg(n,:));
end
q_enc = [q_time,q_pos];

% ATTEMPT 1: Generate qd_enc by just taking a diff of each q_enc step. Not
% actually using calculated qds!
for n = 1:q_row
    qd_enc = diff(q_enc)/prd;
end
q_enc = [q_enc,[qd_enc(:,2:5);zeros(1,4)]];

% Plot to compare trajectories
if show
    figure;
    subplot(4,1,1);
    plot(q_enc(:,1),q_enc(:,2),q_enc(:,1),q_enc(:,6));
    legend('J1\_pos','J1\_vel');
    title('J1 - J4 Encoder Position/Velocity');
    subplot(4,1,2);
    plot(q_enc(:,1),q_enc(:,3),q_enc(:,1),q_enc(:,7));
    legend('J2\_pos','J2\_vel');
    subplot(4,1,3);
    plot(q_enc(:,1),q_enc(:,4),q_enc(:,1),q_enc(:,8));
    legend('J3\_pos','J3\_vel');
    subplot(4,1,4);
    plot(q_enc(:,1),q_enc(:,5),q_enc(:,1),q_enc(:,9));
    legend('J4\_pos','J4\_vel');
end


%% Plot joint positions & velocities to compare outputs
% Transpose qds so it's in the same format as the other vectors
qds = qds';

figure;
ax1 = subplot(3,2,1);
p1 = get(ax1,'pos');
[ax1,H1_1,H2_1] = plotyy(q_enc(:,1),q_enc(:,2),q_enc(:,1),rad2deg(q(:,1))); % Plot J1 position (counts) vs time, J1 position(deg) vs. time on diff axes
title('Joint 1 Position');
legend('J1 Counts','J1 Degrees');

ax2 = subplot(3,2,3);
p2 = get(ax2,'pos');
[ax2,H1_2,H2_2] = plotyy(q_enc(:,1),q_enc(:,4),q_enc(:,1),rad2deg(q(:,2))); % Plot J1 position (counts) vs time, J1 position(deg) vs. time on diff axes
title('Joint 3 Position');
legend('J3 Volts','J3 Degrees');

ax3 = subplot(3,2,5);
p3 = get(ax3,'pos');
[ax3,H1_3,H2_3] = plotyy(q_enc(:,1),q_enc(:,5),q_enc(:,1),rad2deg(q(:,3)));
title('Joint 4 Position');
legend('J4 Volts','J4 mm');

ax4 = subplot(3,2,2);
p4 = get(ax4,'pos');
[ax4,H1_4,H2_4] = plotyy(q_enc(:,1),q_enc(:,6),q_enc(:,1),rad2deg(qds(:,1))); % Plot J1 position (counts) vs time, J1 position(deg) vs. time on diff axes
title('Joint 1 Velocity');
legend('J1 Counts','J1 Degrees');

ax5 = subplot(3,2,4);
p5 = get(ax5,'pos');
[ax5,H1_5,H2_5] = plotyy(q_enc(:,1),q_enc(:,8),q_enc(:,1),rad2deg(qds(:,2))); % Plot J1 position (counts) vs time, J1 position(deg) vs. time on diff axes
title('Joint 3 Velocity');
legend('J3 Volts','J3 Degrees');

ax6 = subplot(3,2,6);
p6 = get(ax6,'pos');
[ax6,H1_6,H2_6] = plotyy(q_enc(:,1),q_enc(:,9),q_enc(:,1),rad2deg(qds(:,3)));
title('Joint 4 Velocity');
legend('J4 Volts','J4 mm');

end